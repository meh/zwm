#! /bin/zsh
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
#                    Version 2, December 2004
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
#   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.

# Initialization {{{
emulate -L zsh

zmodload -i zsh/net/socket
zmodload -i zsh/system
zmodload -i zsh/zselect

# setopt XTRACE
# }}}

# Misc Helpers {{{
function warn {
	print -- "$*" >&2
}

function is-true {
	[[ "$1" == (1|[Yy]([Ee][Ss]|)|[Tt]([Rr][Uu][Ee]|)|[Oo]([Nn]|)) ]]
}
# }}}

# X Helpers {{{
function X:dial {
	local display
	local screen
	local socket
	local protocol

	local -a parts
	parts=("${(@s[:])1:-$DISPLAY}")

	if [[ -n $parts[1] ]]; then
		if [[ "${${parts[1]}[1]}" == '/' ]]; then
			display="${parts[2]}"
			socket="${parts[1]}:"
			protocol='unix'
		else
			# TODO: implement other protocols
		fi
	else
		display="$parts[1]"
		socket='/tmp/.X11-unix/X'
		protocol='unix'
	fi

	parts=(${(@s[.])parts[-1]})
	display="$parts[1]"
	screen="$parts[2]"

	integer REPLY
	case "$protocol" in
		unix)
			if [[ ! -S "$socket$display" ]]; then
				return 1
			fi

			zsocket "$socket$display" || return $?
			DISPLAY_FD=$REPLY

			;;

		*) return 1 ;;
	esac
}

function X:connect {
	X:dial $1 || return 1
	X:auth:read || return 1

	X:packet:setup:write \
		endianness big \
\
		protocol.version.major 11 \
		protocol.version.minor 0 \
\
		auth.name "$reply[name]" \
		auth.data "$reply[data]"

	local -A setup
	X:packet:setup:read setup

	if (( $setup[protocol.version.major] < 11 )); then
		warn 'WHAT YEAR IS THIS?!?!?'
		exit 1
	fi

	if (( $setup[protocol.version.major] > 11 )); then
		warn 'Tell me about the future.'
		exit 1
	fi
}

function X:write {
	syswrite -o $DISPLAY_FD "$*"
}

function X:read {
	sysread -i $DISPLAY_FD -s "$1" $2
}

# Types {{{
function X:XID:write {
	if (( (($1 >> 24) & 0xff) >> 6 != 0 )); then
		warn 'XID: top three bits must be 0'
		return 1
	fi

	local encoded="\x$(( [##16] ($1 >> 24) & 0xff))\x$(( [##16] ($1 >> 16) & 0xff))\x$(( [##16] ($1 >> 8) & 0xff))\x$(( [##16] $1 & 0xff ))"

	X:write "${(g::)encoded}"
}

alias X:WINDOW:write=X:XID:write
alias X:COLORMAP:write=X:XID:write

function X:XID:read {
	X:read 4

	local first="$REPLY[1]"
	local second="$REPLY[2]"
	local third="$REPLY[3]"
	local fourth="$REPLY[3]"

	typeset -g "${1:-REPLY}=$(( #first << 24 | #second << 16 | #third << 8 | #fourth ))"
}

alias X:WINDOW:read=X:XID:read
alias X:COLORMAP:read=X:XID:read

function X:BOOL:write {
	if is-true "$1"; then
		X:CARD8:write 1
	else
		X:CARD8:write 0
	fi
}

function X:BOOL:read {
	X:CARD8:read
}

function X:CARD8:write {
	local encoded="\x$(( [##16] $1 & 0xff ))"

	X:write "${(g::)encoded}"
}

alias X:BYTE:write=X:CARD8:write

function X:CARD8:read {
	X:read 1

	typeset -g "${1:-REPLY}=$(( #REPLY ))"
}

alias X:BYTE:read=X:CARD8:read

function X:CARD16:write {
	local encoded="\x$(( [##16] ($1 >> 8) & 0xff))\x$(( [##16] $1 & 0xff ))"

	X:write "${(g::)encoded}"
}

function X:CARD16:read {
	X:read 2

	local first="$REPLY[1]"
	local second="$REPLY[2]"

	typeset -g "${1:-REPLY}=$(( #first << 8 | #second ))"
}

function X:CARD32:write {
	local encoded="\x$(( [##16] ($1 >> 24) & 0xff))\x$(( [##16] ($1 >> 16) & 0xff))\x$(( [##16] ($1 >> 8) & 0xff))\x$(( [##16] $1 & 0xff ))"

	X:write "${(g::)encoded}"
}

alias X:VISUALID:write=X:CARD32:write

function X:CARD32:read {
	X:read 4

	local first="$REPLY[1]"
	local second="$REPLY[2]"
	local third="$REPLY[3]"
	local fourth="$REPLY[3]"

	typeset -g "${1:-REPLY}=$(( #first << 24 | #second << 16 | #third << 8 | #fourth ))"
}

alias X:VISUALID:read=X:CARD32:read

function X:STRING8:write {
	# add padding
	repeat $(( (4 - ($#1 % 4)) % 4 )) 1+=$'\0'

	X:write "$1"
}

function X:STRING8:read {
	X:read $argv[-1] $1

	if (( $argv[-1] % 4 != 0 )); then
		local waste
		X:read $(( 4 - ($argv[-1] % 4) ))
	fi
}
# }}}

# Packets {{{
function X:packet:setup {
	typeset -gA data

	if (( ! $+2 )); then
		data=("${(@P)1}")
	else
		data=("$@")
	fi
}

function X:packet:setup:write {
	local -A data

	X:packet:setup "$@"

	# the first byte tells the endianness to use: B for big, l for little
	if [[ "${data[endianness]:l}" == 'big' ]]; then
		X:write 'B'
	elif [[ "${data[endianness]:l}" == 'little' ]]; then
		X:write 'l'
	else
		return 1
	fi

	# there's an unused byte
	X:write $'\0'

	# the major and minor version for the protocol we talk
	X:CARD16:write "$data[protocol.version.major]"
	X:CARD16:write "$data[protocol.version.minor]"

	# the length of the auth name and auth data
	X:CARD16:write "$#data[auth.name]"
	X:CARD16:write "$#data[auth.data]"

	# two unused bytes
	X:write $'\0\0'

	# and the 4 bytes padded auth name and auth data
	X:STRING8:write "$data[auth.name]"
	X:STRING8:write "$data[auth.data]"
}

function X:packet:setup:read {
	: ${1:=reply}

	integer code

	X:CARD8:read code

	# Failure
	if (( $code == 0 )); then
		integer reason_length

		X:CARD8:read reason_length
		X:CARD16:read "$1[protocol.version.major]"
		X:CARD16:read "$1[protocol.version.minor]"
		X:CARD16:read # what's this length for?
		X:STRING8:read "$1[reason]" $reason_length

		return 1
	fi

	# Authenticate
	if (( $code == 2 )); then
		integer reason_length

		X:read 5
		X:CARD16:read reason_length
		X:STRING8:read "$1[reason]" $(( length * 4 ))

		return 2
	fi

	X:read 1

	integer vendor_len
	integer screens_len
	integer pixmap_formats_len

	X:CARD16:read "$1[protocol.version.major]"
	X:CARD16:read "$1[protocol.version.minor]"
	X:CARD16:read # unused length
	X:CARD32:read "$1[protocol.version.release-number]"
	X:CARD32:read "$1[resource-id.base]"
	X:CARD32:read "$1[resource-id.mask]"
	X:CARD32:read "$1[motion-buffer.size]"
	X:CARD16:read vendor_len
	X:CARD16:read "$1[request.max-length]"
	X:CARD8:read  screens_len
	X:CARD8:read  pixmap_formats_len
	X:CARD8:read  "$1[image.byte-order]"
	X:CARD8:read  "$1[bitmap-format.byte-order]"
	X:CARD8:read  "$1[bitmap-format.scanline.unit]"
	X:CARD8:read  "$1[bitmap-format.scanline.pad]"
	X:CARD8:read  "$1[keycode.min]"
	X:CARD8:read  "$1[keycode.max]"

	typeset -g "$1[image.byte-order]=${${(P)${:-$1[image.byte-order]}/0/little}/1/big}"
	typeset -g "$1[bitmap-format.byte-order]=${${(P)${:-$1[bitmap-format.byte-order]}/0/little}/1/big}"

	X:read 4
	X:STRING8:read "$1[vendor]" $vendor_len

	integer i
	typeset -g "$1[pixmap-formats.length]=$pixmap_formats_len"
	for (( i=1; i <= $pixmap_formats_len; ++i )); do
		X:CARD8:read "$1[pixmap-formats.$i.depth]"
		X:CARD8:read "$1[pixmap-formats.$i.bits-per-pixel]"
		X:CARD8:read "$1[pixmap-formats.$i.scanline.pad]"
		X:read 5
	done

	integer i
	typeset -g "$1[screens.length]=$screens_len"
	for (( i=1; i <= $screens_len; ++i )); do
		integer allowed_depths_len

		X:WINDOW:read   "$1[screens.$i.window]"
		X:COLORMAP:read "$1[screens.$i.default-colormap]"
		X:CARD32:read   "$1[screens.$i.pixel.white]"
		X:CARD32:read   "$1[screens.$i.pixel.black]"
		X:CARD32:read   "$1[screens.$i.current-input-masks]"
		X:CARD16:read   "$1[screens.$i.width.px]"
		X:CARD16:read   "$1[screens.$i.height.px]"
		X:CARD16:read   "$1[screens.$i.width.mm]"
		X:CARD16:read   "$1[screens.$i.height.mm]"
		X:CARD16:read   "$1[screens.$i.installed-maps.min]"
		X:CARD16:read   "$1[screens.$i.installed-maps.max]"
		X:VISUALID:read "$1[screens.$i.visual]"
		X:BYTE:read     "$1[screens.$i.backing-stores]"
		X:BOOL:read     "$1[screens.$i.save-unders]"
		X:CARD8:read    "$1[screens.$i.depth]"
		X:CARD8:read    allowed_depths_len

		integer j
		typeset -g "$1[screens.$i.allowed-depths.length]=$allowed_depths_len"
		for (( j=1; j <= $allowed_depths_len; ++j )); do
			integer visuals_len

			X:CARD8:read "$1[screens.$i.allowed-depths.$j.depth]"
			X:read 1
			X:CARD16:read visuals_len
			X:read 4

			integer h
			typeset -g "$1[screens.$i.allowed-depths.$j.visuals.length]=$visuals_len"
			for (( h=1; h <= $visuals_len; ++h )); do
				X:VISUALID:read "$1[screens.$i.allowed-depths.$j.visuals.$h.id]"
				X:CARD8:read    "$1[screens.$i.allowed-depths.$j.visuals.$h.class]"
				X:CARD8:read    "$1[screens.$i.allowed-depths.$j.visuals.$h.bits-per-rgb-value]"
				X:CARD16:read   "$1[screens.$i.allowed-depths.$j.visuals.$h.colormap-entries]"
				X:CARD32:read   "$1[screens.$i.allowed-depths.$j.visuals.$h.mask.red]"
				X:CARD32:read   "$1[screens.$i.allowed-depths.$j.visuals.$h.mask.green]"
				X:CARD32:read   "$1[screens.$i.allowed-depths.$j.visuals.$h.mask.blue]"
				X:read 4
			done
		done
	done
}
# }}}

# Authentication {{{
function X:auth:read-short {
	integer fd="$2"
	local encoded

	sysread -i $fd -s 2 encoded || return $?

	local first="$encoded[1]"
	local second="$encoded[2]"

	typeset -g "${1:-REPLY}=$(( #first << 8 | #second ))"
}

function X:auth:read-string {
	integer fd="$2"
	integer length

	X:auth:read-short length "$fd"
	sysread -i $fd -s $length $1 || return $?
}

function X:auth:read {
	local display="$2"
	local hostname="${3:-$HOST}"
	local authority="${XAUTHORITY:-$HOME/.Xauthority}"
	integer fd

	exec {fd}<"$authority"

	if [[ -z $fd ]]; then
		return 1
	fi

	integer family
	local addr
	local disp
	local name
	local data

	while true; do
		X:auth:read-short  family $fd || break
		X:auth:read-string addr   $fd || break
		X:auth:read-string disp   $fd || break
		X:auth:read-string name   $fd || break
		X:auth:read-string data   $fd || break

		if [[ "$family" == 256 && "$addr" == "$hostname" && "$disp" == "$display" ]]; then
			set -A "${1:-reply}" name "$name" data "$data"

			break
		fi
	done

	exec {fd}>&-

	(( ${#${(P)1:-reply}} ))
}
# }}}

# }}}

integer -g DISPLAY_FD
local -A args

while true; do
	case "$1" in
		-display)
			args[display]="$2"

			shift 2 ;;

		-version)
			print 'zwm 0.0.1 (http://github.com/meh/zwm)'

			exit ;;

		-help)
			cat <<- HELP
				zwm 0.0.1 (http://github.com/meh/zwm)
				
				-display <string>  use display connection
				-version           display version and exit
				-help              display this help text and exit
HELP

			exit ;;

		-*)
			1='-help' ;;

		*) break ;;
	esac
done

if ! X:connect "$args[display]"; then
	warn 'zwm: connection failed'
	exit 1
fi

# vim: ft=zsh sts=2 ts=2 sw=2 noet fdm=marker fmr={{{,}}}
